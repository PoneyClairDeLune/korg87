var l=Object.defineProperty;var f=(e,t,r)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var y=(e,t,r)=>(f(e,typeof t!="symbol"?t+"":t,r),r);var n=function(e,t,r=!1){if(!t&&!r)throw new TypeError("Type is not defined");if(e?.constructor){if(e.constructor!=t)throw new TypeError(`Value is not type ${t.name}`)}else if(!r)throw new TypeError("Value is not nullable")};var c=function(e){let t;switch(e?.constructor){case Uint8Array:{t=e;break}case Int8Array:case Uint8ClampedArray:case Int16Array:case Uint16Array:case Int32Array:case Uint32Array:case Float32Array:case BigInt64Array:case BigUint64Array:case Float64Array:t=new Uint8Array(e.buffer,e.buffer.byteOffset,e.buffer.byteLength);default:throw new TypeError("Unaccepted type for conversion")}return t};var d=function(e,t=1,r,i=1,h){n(e,Uint8Array),n(r,Uint8Array),n(t,Number),n(i,Number);for(let o=0,a=0;o<e.length;o+=t,a+=i)h(e.subarray(o,o+t),r.subarray(a,a+i))},s,u=(s=class{static encodeLength(e){return n(e,Number),Math.ceil(e*this.chunkSizeDec/this.chunkSizeEnc)}static decodeLength(e){return n(e,Number),Math.floor(e*this.chunkSizeEnc/this.chunkSizeDec)}static encodeBlock(e,t){if(n(e,Uint8Array),n(t,Uint8Array),e.length>this.chunkSizeEnc)throw new Error(`Source (${e.length}) is greater than ${this.chunkSizeEnc} bytes`);if(t.length<this.encodeLength(e.length))throw new Error(`Target (${t.length}) isn't sufficient for encoding`);let r=0;e.forEach((i,h)=>{t[h+1]=i&127,r|=i>>7<<h}),t[0]=r}static decodeBlock(e,t){if(n(e,Uint8Array),n(t,Uint8Array),e.length>this.chunkSizeDec)throw new Error(`Source (${e.length}) is greater than ${this.chunkSizeEnc} bytes`);if(t.length<this.decodeLength(e.length))throw new Error(`Target (${t.length}) isn't sufficient for decoding`);let r=e[0];e.subarray(1).forEach((i,h)=>{t[h]=i|(r>>h&1)<<7})}static encodeBytes(e,t){if(n(e,Uint8Array),n(t,Uint8Array),t.length<this.encodeLength(e.length))throw new Error("Target isn't sufficient for encoding");d(e,this.chunkSizeEnc,t,this.chunkSizeDec,(r,i)=>{this.encodeBlock(r,i)})}static decodeBytes(e,t){if(n(e,Uint8Array),n(t,Uint8Array),t.length<this.decodeLength(e.length))throw new Error("Target isn't sufficient for decoding");d(e,this.chunkSizeDec,t,this.chunkSizeEnc,(r,i)=>{this.decodeBlock(r,i)})}static encodeSync(e,t){this.encodeBytes(c(e),c(t))}static decodeSync(e,t){this.decodeBytes(c(e),c(t))}static async encode(e,t){this.encodeBytes(c(e),c(t))}static async decode(e,t){this.decodeBytes(c(e),c(t))}},y(s,"chunkSizeEnc",7),y(s,"chunkSizeDec",8),s);export{u as Korg87};
