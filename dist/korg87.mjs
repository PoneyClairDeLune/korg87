var d=Object.defineProperty;var y=(e,t,n)=>t in e?d(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var l=(e,t,n)=>(y(e,typeof t!="symbol"?t+"":t,n),n);var i=function(e,t,n=!1){if(!t&&!n)throw new TypeError("Type is not defined");if(e?.constructor){if(e.constructor!=t)throw new TypeError(`Value is not type ${t.name}`)}else if(!n)throw new TypeError("Value is not nullable")},a=function(e,t=1,n,r=1,h){i(e,Uint8Array),i(n,Uint8Array),i(t,Number),i(r,Number);for(let c=0,s=0;c<e.length;c+=t,s+=r)h(e.subarray(c,c+t),n.subarray(s,s+r))},o,w=(o=class{static encodeLength(e){return i(e,Number),Math.ceil(e*this.chunkSizeDec/this.chunkSizeEnc)}static decodeLength(e){return i(e,Number),Math.floor(e*this.chunkSizeEnc/this.chunkSizeDec)}static encodeBlock(e,t){if(i(e,Uint8Array),i(t,Uint8Array),e.length>this.chunkSizeEnc)throw new Error(`Source (${e.length}) is greater than ${this.chunkSizeEnc} bytes`);if(t.length<this.encodeLength(e.length))throw new Error(`Target (${t.length}) isn't sufficient for encoding`);let n=0;e.forEach((r,h)=>{t[h+1]=r&127,n|=r>>7<<h}),t[0]=n}static decodeBlock(e,t){if(i(e,Uint8Array),i(t,Uint8Array),e.length>this.chunkSizeDec)throw new Error(`Source (${e.length}) is greater than ${this.chunkSizeEnc} bytes`);if(t.length<this.decodeLength(e.length))throw new Error(`Target (${t.length}) isn't sufficient for decoding`);let n=e[0];e.subarray(1).forEach((r,h)=>{t[h]=r|(n>>h&1)<<7})}static encodeBytes(e,t){if(i(e,Uint8Array),i(t,Uint8Array),t.length<this.encodeLength(e.length))throw new Error("Target isn't sufficient for encoding");a(e,this.chunkSizeEnc,t,this.chunkSizeDec,(n,r)=>{this.encodeBlock(n,r)})}static decodeBytes(e,t){if(i(e,Uint8Array),i(t,Uint8Array),t.length<this.decodeLength(e.length))throw new Error("Target isn't sufficient for decoding");a(e,this.chunkSizeDec,t,this.chunkSizeEnc,(n,r)=>{this.decodeBlock(n,r)})}},l(o,"chunkSizeEnc",7),l(o,"chunkSizeDec",8),o);export{w as Korg87};
